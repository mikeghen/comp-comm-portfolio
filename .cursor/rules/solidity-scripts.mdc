---
description: When writing Solidity Foundry Deployment Scripts follow these coding standards
globs:
---

* **One Script, One Responsibility:** Write each script as a single-purpose contract extending Foundry’s `Script`. **Each script should have exactly one public function** – the `run()` function – which serves as the entry point. Do not define multiple public functions in one script; if you have multiple distinct operations (e.g. deployment vs. an upgrade vs. a parameter tweak), create separate script files for each. This convention (enforced by ScopeLift’s lint checks) makes scripts easier to understand and compose.
* **Deploy Contracts in `Deploy.sol`:** Follow ScopeLift’s template by creating a `script/Deploy.sol` script that handles the full deployment of your system. In `run()`, deploy all necessary contracts and perform initial setup calls. Store deployed contract addresses or references in state variables (preferably public) of the script contract. This way, your tests can inherit this script to access the deployed instances. The deploy script should reflect the real deployment process as closely as possible – for example, if an initializer or a post-deploy configuration step is needed, include it in `run()`.
* **Use Broadcast and Environment Controls:** Utilize Foundry’s cheat codes for scripting. For actual network deployment, surround creation and setup transactions with `vm.startBroadcast(<privateKey>); ... vm.stopBroadcast();` so that running `forge script` will broadcast those transactions. Use `vm.chainId` or `vm.selectFork` if you need to script on a specific chain or fork for testing. **Never hardcode sensitive values** – use `vm.envUint("KEY_NAME")`, `vm.envAddress`, etc., to fetch configuration like deployer private keys, addresses, or API URLs from the environment (`.env` file), keeping secrets out of code.
* **Clarity and Idempotence:** Write scripts that are easy to follow and can be rerun safely. A fellow engineer should be able to read the `run()` sequence and understand the deployment at a glance. Avoid complex loops or logic in scripts; any complexity should reside in the contracts, not the deployment script. Scripts should typically just instantiate contracts, call initialization functions, and log output. If a script is meant to be run in a forked environment for testing, include comments or checks to prevent accidental mainnet execution (for example, checking `require(block.chainid == someTestChainId)` in a test script).
* **Testing and Integration:** Treat your scripts as part of the deliverable code – they should be tested too. By inheriting the deploy script in your test suite (as mentioned in Rule 2), you ensure it gets executed in tests. Additionally, you can write specific script tests (e.g., a script that calls an upgrade function can be run on a fork and assertions made after running it). ScopeLift emphasizes that deployment and upgrade scripts are properly vetted; including them in the test process catches errors in deployment logic early. Also consider running static analysis (e.g. Slither) on scripts – the ScopeLift template does this by default – since scripts often carry out critical admin operations.